use crate::end_device::*;
use crate::envelope::*;
use crate::error::DomainResult;
use crate::gateway::*;
use crate::organization::*;
use async_trait::async_trait;

/// Repository trait for device storage operations
/// Infrastructure layer (e.g., ponix-postgres) implements this trait
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait DeviceRepository: Send + Sync {
    /// Create a new device (device_id is already generated by domain service)
    async fn create_device(&self, input: CreateDeviceInputWithId) -> DomainResult<Device>;

    /// Get a device by ID
    async fn get_device(&self, input: GetDeviceInput) -> DomainResult<Option<Device>>;

    /// List all devices for an organization
    async fn list_devices(&self, input: ListDevicesInput) -> DomainResult<Vec<Device>>;
}

/// Repository trait for organization storage operations
/// Infrastructure layer (e.g., ponix-postgres) implements this trait
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait OrganizationRepository: Send + Sync {
    /// Create a new organization (id is already generated by domain service)
    async fn create_organization(
        &self,
        input: CreateOrganizationInputWithId,
    ) -> DomainResult<Organization>;

    /// Get an organization by ID (excludes soft deleted)
    async fn get_organization(
        &self,
        input: GetOrganizationInput,
    ) -> DomainResult<Option<Organization>>;

    /// Update an organization
    async fn update_organization(
        &self,
        input: UpdateOrganizationInput,
    ) -> DomainResult<Organization>;

    /// Soft delete an organization
    async fn delete_organization(&self, input: DeleteOrganizationInput) -> DomainResult<()>;

    /// List all active organizations (excludes soft deleted)
    async fn list_organizations(
        &self,
        input: ListOrganizationsInput,
    ) -> DomainResult<Vec<Organization>>;
}

/// Repository trait for processed envelope storage operations
/// Infrastructure layer (e.g., ponix-clickhouse) implements this trait
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait ProcessedEnvelopeRepository: Send + Sync {
    /// Store a batch of processed envelopes
    /// Implementations should handle chunking if needed for large batches
    /// Failure handling: entire batch fails atomically (all-or-nothing)
    async fn store_batch(&self, input: StoreEnvelopesInput) -> DomainResult<()>;
}

/// Trait for publishing processed envelopes to message broker
///
/// Implementations should:
/// - Serialize envelope to appropriate format (protobuf)
/// - Publish to message broker (NATS JetStream)
/// - Return error if publish fails
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait ProcessedEnvelopeProducer: Send + Sync {
    /// Publish a single processed envelope
    ///
    /// # Arguments
    /// * `envelope` - ProcessedEnvelope to publish
    ///
    /// # Returns
    /// () on success, DomainError on failure
    async fn publish(&self, envelope: &ProcessedEnvelope) -> DomainResult<()>;
}

/// Trait for publishing raw envelopes to message broker
///
/// Implementations should:
/// - Serialize envelope to appropriate format (protobuf)
/// - Publish to message broker (NATS JetStream)
/// - Return error if publish fails
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait RawEnvelopeProducer: Send + Sync {
    /// Publish a single raw envelope
    ///
    /// # Arguments
    /// * `envelope` - RawEnvelope to publish
    ///
    /// # Returns
    /// () on success, DomainError on failure
    async fn publish(&self, envelope: &RawEnvelope) -> DomainResult<()>;
}

/// Repository trait for gateway persistence operations
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait GatewayRepository: Send + Sync {
    /// Create a new gateway
    async fn create_gateway(&self, input: CreateGatewayInputWithId) -> DomainResult<Gateway>;

    /// Get a gateway by ID (excludes soft deleted)
    async fn get_gateway(&self, gateway_id: &str) -> DomainResult<Option<Gateway>>;

    /// Update a gateway
    async fn update_gateway(&self, input: UpdateGatewayInput) -> DomainResult<Gateway>;

    /// Soft delete a gateway
    async fn delete_gateway(&self, gateway_id: &str) -> DomainResult<()>;

    /// List gateways by organization (excludes soft deleted)
    async fn list_gateways(&self, organization_id: &str) -> DomainResult<Vec<Gateway>>;

    /// List all non-deleted gateways across all organizations
    async fn list_all_gateways(&self) -> DomainResult<Vec<Gateway>>;
}
