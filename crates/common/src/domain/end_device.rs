use crate::domain::result::DomainResult;
use async_trait::async_trait;
use chrono::{DateTime, Utc};

/// Domain representation of a Device
/// Simple String types for now - can evolve to newtypes later
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Device {
    pub device_id: String,
    pub organization_id: String,
    pub name: String,
    pub payload_conversion: String,
    pub created_at: Option<DateTime<Utc>>,
    pub updated_at: Option<DateTime<Utc>>,
}

/// Input for creating a new device (from external callers like gRPC)
/// Note: device_id is generated by the domain service
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CreateDeviceInput {
    pub organization_id: String,
    pub name: String,
    pub payload_conversion: String,
}

/// Internal input for creating a new device (used by domain service -> repository)
/// Includes the generated device_id
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CreateDeviceInputWithId {
    pub device_id: String,
    pub organization_id: String,
    pub name: String,
    pub payload_conversion: String,
}

/// Input for retrieving a device
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct GetDeviceInput {
    pub device_id: String,
}

/// Input for listing devices by organization
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ListDevicesInput {
    pub organization_id: String,
}

/// Repository trait for device storage operations
/// Infrastructure layer (e.g., ponix-postgres) implements this trait
#[cfg_attr(any(test, feature = "testing"), mockall::automock)]
#[async_trait]
pub trait DeviceRepository: Send + Sync {
    /// Create a new device (device_id is already generated by domain service)
    async fn create_device(&self, input: CreateDeviceInputWithId) -> DomainResult<Device>;

    /// Get a device by ID
    async fn get_device(&self, input: GetDeviceInput) -> DomainResult<Option<Device>>;

    /// List all devices for an organization
    async fn list_devices(&self, input: ListDevicesInput) -> DomainResult<Vec<Device>>;
}
