# Add Organization Entity with CRUD Operations

## Overview

Add Organization entity to the ponix-rs system with full CRUD support and soft delete functionality, following existing domain-driven design patterns from the device implementation. Organizations will be integrated with device management, including proper validation and cascade filtering for soft-deleted organizations in both device queries and raw envelope processing.

## Current State Analysis

The system currently has:
- Device entity with organization_id as a string field (no FK constraint)
- Device CRUD operations via gRPC
- Raw envelope processing that fetches devices for CEL expression lookup
- Domain-driven architecture: domain layer (`ponix-domain`), infrastructure layer (`ponix-postgres`), API layer (`ponix-grpc`)
- Protobuf types from BSR (Buf Schema Registry) at version `0.4.x`

**Key patterns to follow** (from device implementation):
- **Two-Type Input Pattern**: `CreateOrganizationInput` (external) + `CreateOrganizationInputWithId` (internal)
- **ID Generation**: Use `xid::new().to_string()` at domain service layer ([end_device_service.rs:36](crates/ponix-domain/src/end_device_service.rs#L36))
- **Repository Trait**: `#[cfg_attr(test, mockall::automock)]` for automatic mock generation ([repository.rs:9](crates/ponix-domain/src/repository.rs#L9))
- **Error Handling**: PostgreSQL error code 23505 → `DomainError::OrganizationAlreadyExists` ([device_repo.rs:54-58](crates/ponix-postgres/src/device_repo.rs#L54-L58))
- **Type Conversions**: Separate conversion functions between proto ↔ domain ([conversions.rs](crates/ponix-grpc/src/conversions.rs))
- **Error Mapping**: Domain errors → gRPC Status codes ([error.rs](crates/ponix-grpc/src/error.rs))

## Desired End State

After implementation:
- Organizations table in PostgreSQL with soft delete support (`deleted_at` timestamp)
- Organization domain entity with service, repository trait, and input types
- Full CRUD gRPC API for organizations (Create, Get, Update, Delete, List)
- Foreign key constraint: `devices.organization_id` → `organizations.id`
- Device queries automatically filter out devices belonging to soft-deleted organizations
- Raw envelope processing rejects messages from devices with deleted organizations
- Comprehensive unit and integration tests

**Verification criteria:**
- Can create organization via gRPC and retrieve by ID
- Soft delete sets `deleted_at` timestamp (organization remains in DB)
- Devices with deleted organizations are excluded from List/Get operations
- Raw envelopes from devices with deleted organizations are rejected with appropriate error
- All automated tests pass

## What We're NOT Doing

- No data migration (no existing data to migrate)
- No uniqueness constraint on organization names (names can be duplicated)
- No cascade delete of devices (soft delete only affects visibility/validation)
- No organization hierarchy or parent-child relationships
- No pagination for list operations (simple implementation first)
- No organization metadata fields beyond name (can add later if needed)

## Implementation Approach

Follow the layered DDD architecture established by devices:
1. Start with database foundation (migrations)
2. Build domain layer (types, service, traits)
3. Implement infrastructure layer (PostgreSQL repository)
4. Add API layer (gRPC handlers)
5. Integrate with existing device functionality
6. Add comprehensive testing at each layer

This approach ensures each layer builds on the previous one, maintaining the separation of concerns and enabling testability at each stage.

---

## Phase 1: Database Schema & Migrations

### Overview
Create the organizations table with soft delete support and add a foreign key constraint to the devices table. This establishes the database foundation for organization management.

### Changes Required

#### 1. Organizations Table Migration
**File**: `crates/ponix-postgres/migrations/YYYYMMDDHHMMSS_create_organizations_table.sql`

```sql
-- +goose Up
-- +goose StatementBegin
CREATE TABLE IF NOT EXISTS organizations (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    deleted_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_organizations_deleted_at ON organizations(deleted_at);
CREATE INDEX idx_organizations_created_at ON organizations(created_at DESC);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
DROP INDEX IF EXISTS idx_organizations_created_at;
DROP INDEX IF EXISTS idx_organizations_deleted_at;
DROP TABLE IF EXISTS organizations;
-- +goose StatementEnd
```

**Rationale:**
- `id TEXT PRIMARY KEY`: Generated by domain service using xid (same as devices)
- `name TEXT NOT NULL`: Organization name (no uniqueness constraint per requirements)
- `deleted_at TIMESTAMP WITH TIME ZONE`: NULL = active, non-NULL = soft deleted
- `created_at`, `updated_at`: Automatic timestamps with `DEFAULT NOW()`
- Index on `deleted_at`: Optimizes queries filtering out deleted organizations
- Index on `created_at DESC`: Supports ordering by creation time in list operations

#### 2. Foreign Key Constraint Migration
**File**: `crates/ponix-postgres/migrations/YYYYMMDDHHMMSS_add_organization_fk_to_devices.sql`

```sql
-- +goose Up
-- +goose StatementBegin
ALTER TABLE devices
ADD CONSTRAINT fk_devices_organization
FOREIGN KEY (organization_id)
REFERENCES organizations(id);

CREATE INDEX idx_devices_organization_id_fk ON devices(organization_id);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
DROP INDEX IF EXISTS idx_devices_organization_id_fk;
ALTER TABLE devices
DROP CONSTRAINT IF EXISTS fk_devices_organization;
-- +goose StatementEnd
```

**Rationale:**
- Foreign key enforces referential integrity at database level
- Index on FK improves JOIN performance for device queries
- Note: Existing `idx_devices_organization_id` index may need evaluation for redundancy

### Success Criteria

#### Automated Verification:
- [x] Migrations apply cleanly: `mise run test:integration` (uses testcontainers)
- [x] Can create organization in test: `INSERT INTO organizations (id, name) VALUES ('test-org', 'Test')`
- [x] Foreign key constraint enforced: Device insert with invalid org_id fails
- [x] Soft delete preserves row: `UPDATE organizations SET deleted_at = NOW()` keeps row in database
- [x] Indexes exist: Query `pg_indexes` table confirms all indexes created

#### Manual Verification:
- [ ] Run migrations on local development database: `docker exec ponix-postgres psql -U ponix -d ponix -c "SELECT * FROM organizations LIMIT 5"`
- [ ] Verify indexes created: Check `\d organizations` in psql shows correct indexes
- [ ] Test FK constraint manually: Try inserting device with non-existent organization_id

**Implementation Note**: After completing this phase and all automated verification passes, the database schema is ready for domain layer implementation.

---

## Phase 2: Domain Layer - Organization Types & Service

### Overview
Implement the domain layer for organizations, including types, service logic, repository trait, and comprehensive error handling. This follows the same patterns established by the device implementation.

### Changes Required

#### 1. Domain Types
**File**: `crates/ponix-domain/src/organization.rs` (new file)

```rust
use chrono::{DateTime, Utc};

/// Organization domain entity
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Organization {
    pub id: String,
    pub name: String,
    pub deleted_at: Option<DateTime<Utc>>,
    pub created_at: Option<DateTime<Utc>>,
    pub updated_at: Option<DateTime<Utc>>,
}

/// External input for creating an organization (no ID)
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CreateOrganizationInput {
    pub name: String,
}

/// Internal input with generated ID
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CreateOrganizationInputWithId {
    pub id: String,
    pub name: String,
}

/// Input for getting an organization by ID
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct GetOrganizationInput {
    pub organization_id: String,
}

/// Input for updating an organization
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UpdateOrganizationInput {
    pub organization_id: String,
    pub name: String,
}

/// Input for deleting an organization
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DeleteOrganizationInput {
    pub organization_id: String,
}

/// Input for listing organizations
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ListOrganizationsInput {}
```

**Pattern notes:**
- Follows Two-Type Pattern: `CreateOrganizationInput` (external) vs `CreateOrganizationInputWithId` (internal)
- `deleted_at` is `Option` - None means active, Some means soft deleted
- Timestamps optional to allow database-generated values
- All input types derive `Debug, Clone, PartialEq, Eq` for testability

#### 2. Repository Trait
**File**: `crates/ponix-domain/src/repository.rs` (modify existing)

```rust
// Add to existing file after DeviceRepository trait

#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait OrganizationRepository: Send + Sync {
    async fn create_organization(&self, input: CreateOrganizationInputWithId) -> DomainResult<Organization>;
    async fn get_organization(&self, input: GetOrganizationInput) -> DomainResult<Option<Organization>>;
    async fn update_organization(&self, input: UpdateOrganizationInput) -> DomainResult<Organization>;
    async fn delete_organization(&self, input: DeleteOrganizationInput) -> DomainResult<()>;
    async fn list_organizations(&self, input: ListOrganizationsInput) -> DomainResult<Vec<Organization>>;
}
```

**Key design points:**
- `#[cfg_attr(test, mockall::automock)]`: Enables automatic mock generation for tests
- `Send + Sync`: Required for Arc<dyn Trait> sharing across async tasks
- `get_organization` returns `Option<Organization>`: None if not found or soft deleted
- `delete_organization` returns `()`: Soft delete doesn't return the deleted entity
- All methods use input types (not individual params) for consistency and extensibility

#### 3. Domain Service
**File**: `crates/ponix-domain/src/organization_service.rs` (new file)

```rust
use crate::error::{DomainError, DomainResult};
use crate::organization::*;
use crate::repository::OrganizationRepository;
use std::sync::Arc;
use tracing::{debug, info};

/// Domain service for organization business logic
pub struct OrganizationService {
    repository: Arc<dyn OrganizationRepository>,
}

impl OrganizationService {
    pub fn new(repository: Arc<dyn OrganizationRepository>) -> Self {
        Self { repository }
    }

    /// Create a new organization with generated ID
    pub async fn create_organization(&self, input: CreateOrganizationInput) -> DomainResult<Organization> {
        debug!(name = %input.name, "Creating organization");

        // Validate name is not empty
        if input.name.trim().is_empty() {
            return Err(DomainError::InvalidOrganizationName(
                "Organization name cannot be empty".to_string(),
            ));
        }

        // Generate unique organization ID using xid
        let organization_id = xid::new().to_string();

        let repo_input = CreateOrganizationInputWithId {
            id: organization_id.clone(),
            name: input.name,
        };

        let organization = self.repository.create_organization(repo_input).await?;

        info!(organization_id = %organization.id, "Organization created successfully");
        Ok(organization)
    }

    /// Get organization by ID (excludes soft deleted)
    pub async fn get_organization(&self, input: GetOrganizationInput) -> DomainResult<Organization> {
        debug!(organization_id = %input.organization_id, "Getting organization");

        if input.organization_id.is_empty() {
            return Err(DomainError::InvalidOrganizationId(
                "Organization ID cannot be empty".to_string(),
            ));
        }

        let organization = self
            .repository
            .get_organization(input)
            .await?
            .ok_or_else(|| DomainError::OrganizationNotFound(input.organization_id.clone()))?;

        Ok(organization)
    }

    /// Update organization name
    pub async fn update_organization(&self, input: UpdateOrganizationInput) -> DomainResult<Organization> {
        debug!(organization_id = %input.organization_id, "Updating organization");

        if input.organization_id.is_empty() {
            return Err(DomainError::InvalidOrganizationId(
                "Organization ID cannot be empty".to_string(),
            ));
        }

        if input.name.trim().is_empty() {
            return Err(DomainError::InvalidOrganizationName(
                "Organization name cannot be empty".to_string(),
            ));
        }

        let organization = self.repository.update_organization(input).await?;

        info!(organization_id = %organization.id, "Organization updated successfully");
        Ok(organization)
    }

    /// Soft delete organization
    pub async fn delete_organization(&self, input: DeleteOrganizationInput) -> DomainResult<()> {
        debug!(organization_id = %input.organization_id, "Deleting organization");

        if input.organization_id.is_empty() {
            return Err(DomainError::InvalidOrganizationId(
                "Organization ID cannot be empty".to_string(),
            ));
        }

        self.repository.delete_organization(input).await?;

        info!(organization_id = %input.organization_id, "Organization soft deleted successfully");
        Ok(())
    }

    /// List all active organizations (excludes soft deleted)
    pub async fn list_organizations(&self, input: ListOrganizationsInput) -> DomainResult<Vec<Organization>> {
        debug!("Listing organizations");

        let organizations = self.repository.list_organizations(input).await?;

        info!(count = organizations.len(), "Listed organizations");
        Ok(organizations)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::repository::MockOrganizationRepository;

    #[tokio::test]
    async fn test_create_organization_success() {
        let mut mock_repo = MockOrganizationRepository::new();

        let expected_org = Organization {
            id: "generated-id".to_string(),
            name: "Test Org".to_string(),
            deleted_at: None,
            created_at: Some(chrono::Utc::now()),
            updated_at: Some(chrono::Utc::now()),
        };

        mock_repo
            .expect_create_organization()
            .withf(|input: &CreateOrganizationInputWithId| {
                !input.id.is_empty() && input.name == "Test Org"
            })
            .times(1)
            .return_once(move |_| Ok(expected_org.clone()));

        let service = OrganizationService::new(Arc::new(mock_repo));
        let input = CreateOrganizationInput {
            name: "Test Org".to_string(),
        };

        let result = service.create_organization(input).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().name, "Test Org");
    }

    #[tokio::test]
    async fn test_create_organization_empty_name() {
        let mock_repo = MockOrganizationRepository::new();
        let service = OrganizationService::new(Arc::new(mock_repo));

        let input = CreateOrganizationInput {
            name: "".to_string(),
        };

        let result = service.create_organization(input).await;
        assert!(matches!(result, Err(DomainError::InvalidOrganizationName(_))));
    }

    #[tokio::test]
    async fn test_get_organization_not_found() {
        let mut mock_repo = MockOrganizationRepository::new();

        mock_repo
            .expect_get_organization()
            .times(1)
            .return_once(|_| Ok(None));

        let service = OrganizationService::new(Arc::new(mock_repo));
        let input = GetOrganizationInput {
            organization_id: "nonexistent".to_string(),
        };

        let result = service.get_organization(input).await;
        assert!(matches!(result, Err(DomainError::OrganizationNotFound(_))));
    }
}
```

**Pattern notes:**
- ID generation at service layer using `xid::new().to_string()` (same as devices)
- Early input validation before repository calls
- Structured logging with `tracing::{debug, info}`
- Service converts `None` from repository to `OrganizationNotFound` error
- Comprehensive unit tests with Mockall mocks

#### 4. Error Types
**File**: `crates/ponix-domain/src/error.rs` (modify existing)

```rust
// Add new error variants to existing DomainError enum

#[derive(Error, Debug)]
pub enum DomainError {
    // ... existing device errors ...

    #[error("Organization not found: {0}")]
    OrganizationNotFound(String),

    #[error("Organization already exists: {0}")]
    OrganizationAlreadyExists(String),

    #[error("Invalid organization ID: {0}")]
    InvalidOrganizationId(String),

    #[error("Invalid organization name: {0}")]
    InvalidOrganizationName(String),

    #[error("Organization is deleted: {0}")]
    OrganizationDeleted(String),

    // ... existing generic errors ...
}
```

**New error variants:**
- `OrganizationNotFound`: Used when get/update/delete can't find organization
- `OrganizationAlreadyExists`: Used when unique constraint violation occurs
- `InvalidOrganizationId`: Validation error for empty/invalid IDs
- `InvalidOrganizationName`: Validation error for empty/invalid names
- `OrganizationDeleted`: Used when operations attempted on soft-deleted organization

#### 5. Module Exports
**File**: `crates/ponix-domain/src/lib.rs` (modify existing)

```rust
// Add new modules
pub mod organization;
pub mod organization_service;

// Re-export types
pub use organization::*;
pub use organization_service::OrganizationService;
```

### Success Criteria

#### Automated Verification:
- [ ] Unit tests pass: `cargo test -p ponix-domain --lib`
- [ ] Type checking passes: `cargo check -p ponix-domain`
- [ ] Linting passes: `cargo clippy -p ponix-domain -- -D warnings`
- [ ] Documentation builds: `cargo doc -p ponix-domain --no-deps`
- [ ] Mock generation works: `cargo test -p ponix-domain` compiles MockOrganizationRepository

#### Manual Verification:
- [ ] Review service logic for proper validation and error handling
- [ ] Verify ID generation uses xid (same pattern as devices)
- [ ] Confirm Two-Type Pattern implemented correctly
- [ ] Check that service methods have appropriate logging

**Implementation Note**: After completing this phase and all automated verification passes, the domain layer is ready for infrastructure implementation.

---

## Phase 3: Infrastructure Layer - PostgreSQL Repository

### Overview
Implement the OrganizationRepository trait for PostgreSQL, including database models, type conversions, and comprehensive error handling. This follows the same patterns from the device repository implementation.

### Changes Required

#### 1. Database Models
**File**: `crates/ponix-postgres/src/models.rs` (modify existing)

```rust
use chrono::{DateTime, Utc};

/// Database row model for organizations
pub struct OrganizationRow {
    pub id: String,
    pub name: String,
    pub deleted_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Lightweight organization model for inserts
pub struct DbOrganization {
    pub id: String,
    pub name: String,
}
```

**Model separation:**
- `OrganizationRow`: Full database representation with all fields (used in SELECT queries)
- `DbOrganization`: Minimal model for INSERT operations (timestamps handled by DB defaults)

#### 2. Type Conversions
**File**: `crates/ponix-postgres/src/conversions.rs` (modify existing)

```rust
use crate::models::{DbOrganization, OrganizationRow};
use ponix_domain::{CreateOrganizationInputWithId, Organization as DomainOrganization};

/// Convert domain input to database insert model
impl From<&CreateOrganizationInputWithId> for DbOrganization {
    fn from(input: &CreateOrganizationInputWithId) -> Self {
        DbOrganization {
            id: input.id.clone(),
            name: input.name.clone(),
        }
    }
}

/// Convert database row to domain organization
impl From<OrganizationRow> for DomainOrganization {
    fn from(row: OrganizationRow) -> Self {
        DomainOrganization {
            id: row.id,
            name: row.name,
            deleted_at: row.deleted_at,
            created_at: Some(row.created_at),
            updated_at: Some(row.updated_at),
        }
    }
}

/// Convert database model to domain organization (without timestamps)
impl From<DbOrganization> for DomainOrganization {
    fn from(org: DbOrganization) -> Self {
        DomainOrganization {
            id: org.id,
            name: org.name,
            deleted_at: None,
            created_at: None,
            updated_at: None,
        }
    }
}
```

**Conversion strategy:**
- Input → DbOrganization: Strips generated ID, prepares for INSERT
- OrganizationRow → Domain: Full conversion with all database fields
- DbOrganization → Domain: Minimal conversion used after INSERT (timestamps set by repository)

#### 3. Repository Implementation
**File**: `crates/ponix-postgres/src/organization_repository.rs` (new file)

```rust
use crate::client::PostgresClient;
use crate::conversions::*;
use crate::models::{DbOrganization, OrganizationRow};
use async_trait::async_trait;
use ponix_domain::error::{DomainError, DomainResult};
use ponix_domain::organization::*;
use ponix_domain::repository::OrganizationRepository;
use tracing::debug;

pub struct PostgresOrganizationRepository {
    client: PostgresClient,
}

impl PostgresOrganizationRepository {
    pub fn new(client: PostgresClient) -> Self {
        Self { client }
    }
}

#[async_trait]
impl OrganizationRepository for PostgresOrganizationRepository {
    async fn create_organization(&self, input: CreateOrganizationInputWithId) -> DomainResult<Organization> {
        let conn = self.client.get_connection().await?;

        let db_org = DbOrganization::from(&input);

        let result = conn
            .execute(
                "INSERT INTO organizations (id, name) VALUES ($1, $2)",
                &[&db_org.id, &db_org.name],
            )
            .await;

        // Handle unique constraint violation (error code 23505)
        if let Err(e) = result {
            if let Some(db_err) = e.as_db_error() {
                if db_err.code().code() == "23505" {
                    return Err(DomainError::OrganizationAlreadyExists(input.id));
                }
            }
            return Err(DomainError::RepositoryError(e.into()));
        }

        // Fetch the created organization with timestamps
        let row = conn
            .query_one(
                "SELECT id, name, deleted_at, created_at, updated_at FROM organizations WHERE id = $1",
                &[&db_org.id],
            )
            .await?;

        let org_row = OrganizationRow {
            id: row.get("id"),
            name: row.get("name"),
            deleted_at: row.get("deleted_at"),
            created_at: row.get("created_at"),
            updated_at: row.get("updated_at"),
        };

        Ok(org_row.into())
    }

    async fn get_organization(&self, input: GetOrganizationInput) -> DomainResult<Option<Organization>> {
        let conn = self.client.get_connection().await?;

        debug!(organization_id = %input.organization_id, "Fetching organization from database");

        let result = conn
            .query_opt(
                "SELECT id, name, deleted_at, created_at, updated_at
                 FROM organizations
                 WHERE id = $1 AND deleted_at IS NULL",
                &[&input.organization_id],
            )
            .await?;

        Ok(result.map(|row| {
            let org_row = OrganizationRow {
                id: row.get("id"),
                name: row.get("name"),
                deleted_at: row.get("deleted_at"),
                created_at: row.get("created_at"),
                updated_at: row.get("updated_at"),
            };
            org_row.into()
        }))
    }

    async fn update_organization(&self, input: UpdateOrganizationInput) -> DomainResult<Organization> {
        let conn = self.client.get_connection().await?;

        debug!(organization_id = %input.organization_id, "Updating organization in database");

        // Perform update and return affected row count
        let rows_affected = conn
            .execute(
                "UPDATE organizations
                 SET name = $1, updated_at = NOW()
                 WHERE id = $2 AND deleted_at IS NULL",
                &[&input.name, &input.organization_id],
            )
            .await?;

        if rows_affected == 0 {
            return Err(DomainError::OrganizationNotFound(input.organization_id));
        }

        // Fetch updated organization
        let row = conn
            .query_one(
                "SELECT id, name, deleted_at, created_at, updated_at
                 FROM organizations
                 WHERE id = $1",
                &[&input.organization_id],
            )
            .await?;

        let org_row = OrganizationRow {
            id: row.get("id"),
            name: row.get("name"),
            deleted_at: row.get("deleted_at"),
            created_at: row.get("created_at"),
            updated_at: row.get("updated_at"),
        };

        Ok(org_row.into())
    }

    async fn delete_organization(&self, input: DeleteOrganizationInput) -> DomainResult<()> {
        let conn = self.client.get_connection().await?;

        debug!(organization_id = %input.organization_id, "Soft deleting organization");

        let rows_affected = conn
            .execute(
                "UPDATE organizations
                 SET deleted_at = NOW(), updated_at = NOW()
                 WHERE id = $1 AND deleted_at IS NULL",
                &[&input.organization_id],
            )
            .await?;

        if rows_affected == 0 {
            return Err(DomainError::OrganizationNotFound(input.organization_id));
        }

        Ok(())
    }

    async fn list_organizations(&self, _input: ListOrganizationsInput) -> DomainResult<Vec<Organization>> {
        let conn = self.client.get_connection().await?;

        debug!("Listing organizations from database");

        let rows = conn
            .query(
                "SELECT id, name, deleted_at, created_at, updated_at
                 FROM organizations
                 WHERE deleted_at IS NULL
                 ORDER BY created_at DESC",
                &[],
            )
            .await?;

        let organizations = rows
            .into_iter()
            .map(|row| {
                let org_row = OrganizationRow {
                    id: row.get("id"),
                    name: row.get("name"),
                    deleted_at: row.get("deleted_at"),
                    created_at: row.get("created_at"),
                    updated_at: row.get("updated_at"),
                };
                org_row.into()
            })
            .collect();

        Ok(organizations)
    }
}
```

**Key implementation details:**
- All queries filter `deleted_at IS NULL` (except create) to exclude soft-deleted organizations
- Update/delete return `OrganizationNotFound` if no rows affected (already deleted or doesn't exist)
- Delete performs UPDATE to set `deleted_at = NOW()` (soft delete, not hard delete)
- Error code 23505 mapped to `OrganizationAlreadyExists` (same pattern as devices)
- All operations use connection pool via `get_connection()`

#### 4. Module Exports
**File**: `crates/ponix-postgres/src/lib.rs` (modify existing)

```rust
pub mod organization_repository;

pub use organization_repository::PostgresOrganizationRepository;
```

### Testing

#### Integration Tests
**File**: `crates/ponix-postgres/tests/organization_repository_integration.rs` (new file)

```rust
use ponix_domain::organization::*;
use ponix_domain::repository::OrganizationRepository;
use ponix_postgres::{MigrationRunner, PostgresClient, PostgresOrganizationRepository};
use testcontainers::clients::Cli;
use testcontainers_modules::postgres::Postgres;

async fn setup_test_db() -> (testcontainers::Container<'static, Postgres>, PostgresOrganizationRepository) {
    let docker = Cli::default();
    let postgres = docker.run(Postgres::default());

    let host = "localhost";
    let port = postgres.get_host_port_ipv4(5432);

    // Run migrations
    let migrations_dir = format!("{}/migrations", env!("CARGO_MANIFEST_DIR"));
    let dsn = format!("postgres://postgres:postgres@{}:{}/postgres?sslmode=disable", host, port);
    let goose_path = which::which("goose").expect("goose not found");

    let migration_runner = MigrationRunner::new(
        goose_path.to_string_lossy().to_string(),
        migrations_dir,
        "postgres".to_string(),
        dsn,
    );

    migration_runner.run_migrations().await.expect("Migrations failed");

    // Create client
    let client = PostgresClient::new(host, port, "postgres", "postgres", "postgres", 5).unwrap();
    let repository = PostgresOrganizationRepository::new(client);

    (postgres, repository)
}

#[tokio::test]
#[cfg_attr(not(feature = "integration-tests"), ignore)]
async fn test_create_and_get_organization() {
    let (_container, repo) = setup_test_db().await;

    let input = CreateOrganizationInputWithId {
        id: "test-org-123".to_string(),
        name: "Test Organization".to_string(),
    };

    let created = repo.create_organization(input.clone()).await.unwrap();
    assert_eq!(created.id, "test-org-123");
    assert_eq!(created.name, "Test Organization");
    assert!(created.deleted_at.is_none());

    let retrieved = repo
        .get_organization(GetOrganizationInput {
            organization_id: "test-org-123".to_string(),
        })
        .await
        .unwrap();

    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().name, "Test Organization");
}

#[tokio::test]
#[cfg_attr(not(feature = "integration-tests"), ignore)]
async fn test_soft_delete_organization() {
    let (_container, repo) = setup_test_db().await;

    let input = CreateOrganizationInputWithId {
        id: "test-org-456".to_string(),
        name: "To Be Deleted".to_string(),
    };

    repo.create_organization(input).await.unwrap();

    // Soft delete
    repo.delete_organization(DeleteOrganizationInput {
        organization_id: "test-org-456".to_string(),
    })
    .await
    .unwrap();

    // Should not be returned by get (filtered by deleted_at IS NULL)
    let retrieved = repo
        .get_organization(GetOrganizationInput {
            organization_id: "test-org-456".to_string(),
        })
        .await
        .unwrap();

    assert!(retrieved.is_none());
}

#[tokio::test]
#[cfg_attr(not(feature = "integration-tests"), ignore)]
async fn test_update_organization() {
    let (_container, repo) = setup_test_db().await;

    let input = CreateOrganizationInputWithId {
        id: "test-org-789".to_string(),
        name: "Original Name".to_string(),
    };

    repo.create_organization(input).await.unwrap();

    let updated = repo
        .update_organization(UpdateOrganizationInput {
            organization_id: "test-org-789".to_string(),
            name: "Updated Name".to_string(),
        })
        .await
        .unwrap();

    assert_eq!(updated.name, "Updated Name");
}

#[tokio::test]
#[cfg_attr(not(feature = "integration-tests"), ignore)]
async fn test_list_organizations() {
    let (_container, repo) = setup_test_db().await;

    // Create multiple organizations
    for i in 1..=3 {
        let input = CreateOrganizationInputWithId {
            id: format!("org-{}", i),
            name: format!("Organization {}", i),
        };
        repo.create_organization(input).await.unwrap();
    }

    let organizations = repo
        .list_organizations(ListOrganizationsInput {})
        .await
        .unwrap();

    assert_eq!(organizations.len(), 3);
}
```

### Success Criteria

#### Automated Verification:
- [ ] Unit tests pass: `cargo test -p ponix-postgres --lib`
- [ ] Integration tests pass: `cargo test -p ponix-postgres --features integration-tests -- --test-threads=1`
- [ ] Type checking passes: `cargo check -p ponix-postgres`
- [ ] Linting passes: `cargo clippy -p ponix-postgres -- -D warnings`

#### Manual Verification:
- [ ] Verify soft delete preserves row in database: Check `SELECT * FROM organizations WHERE deleted_at IS NOT NULL`
- [ ] Test foreign key constraint: Insert device with organization_id, verify relationship
- [ ] Confirm error handling: Test unique constraint violation, not found cases

**Implementation Note**: After completing this phase and all automated verification passes, the infrastructure layer is ready for API implementation.

---

## Phase 4: gRPC API Layer

### Overview
Implement gRPC service handlers for organization CRUD operations, including protobuf conversions and error mapping. This follows the same patterns from the device gRPC implementation.

### Changes Required

#### 1. Update Protobuf Dependencies
**File**: `crates/ponix-grpc/Cargo.toml` (modify existing)

Update BSR package versions to latest that includes organization definitions:

```toml
[dependencies]
# Update to version with organization types
ponix-proto-prost = { package = "ponix_ponix_community_neoeinstein-prost", version = "0.5.0-YYYYMMDDHHMMSS-<hash>.1", registry = "buf", optional = true }
ponix-proto-tonic = { package = "ponix_ponix_community_neoeinstein-tonic", version = "0.5.0-YYYYMMDDHHMMSS-<hash>.1", registry = "buf", optional = true }
```

**Note**: The exact version will depend on when organization protobuf definitions are published to BSR. Check BSR for latest version with `buf registry module search ponix_ponix_community_neoeinstein`.

#### 2. Conversions
**File**: `crates/ponix-grpc/src/conversions.rs` (modify existing)

```rust
use ponix_domain::organization::*;
use ponix_proto_prost::organization::v1::{Organization as ProtoOrganization};
use prost_types::Timestamp;

// Proto → Domain conversions

pub fn to_create_organization_input(req: CreateOrganizationRequest) -> CreateOrganizationInput {
    CreateOrganizationInput {
        name: req.name,
    }
}

pub fn to_get_organization_input(req: GetOrganizationRequest) -> GetOrganizationInput {
    GetOrganizationInput {
        organization_id: req.organization_id,
    }
}

pub fn to_update_organization_input(req: UpdateOrganizationRequest) -> UpdateOrganizationInput {
    UpdateOrganizationInput {
        organization_id: req.organization_id,
        name: req.name,
    }
}

pub fn to_delete_organization_input(req: DeleteOrganizationRequest) -> DeleteOrganizationInput {
    DeleteOrganizationInput {
        organization_id: req.organization_id,
    }
}

pub fn to_list_organizations_input(_req: ListOrganizationsRequest) -> ListOrganizationsInput {
    ListOrganizationsInput {}
}

// Domain → Proto conversions

pub fn to_proto_organization(org: ponix_domain::Organization) -> ProtoOrganization {
    ProtoOrganization {
        id: org.id,
        name: org.name,
        deleted_at: datetime_to_timestamp(org.deleted_at),
        created_at: datetime_to_timestamp(org.created_at),
        updated_at: datetime_to_timestamp(org.updated_at),
    }
}

// Helper functions (already exist for devices, reuse)
// fn timestamp_to_datetime(ts: Option<Timestamp>) -> Option<DateTime<Utc>> { ... }
// fn datetime_to_timestamp(dt: Option<DateTime<Utc>>) -> Option<Timestamp> { ... }
```

**Pattern notes:**
- Conversions are unidirectional and focused
- Reuse existing timestamp conversion helpers
- Domain ID generation happens in service, not here

#### 3. Error Mapping
**File**: `crates/ponix-grpc/src/error.rs` (modify existing)

```rust
pub fn domain_error_to_status(error: DomainError) -> Status {
    match error {
        // ... existing device error mappings ...

        // Organization errors
        DomainError::OrganizationNotFound(msg) => Status::not_found(msg),
        DomainError::OrganizationAlreadyExists(msg) => Status::already_exists(msg),
        DomainError::InvalidOrganizationId(msg)
        | DomainError::InvalidOrganizationName(msg) => Status::invalid_argument(msg),
        DomainError::OrganizationDeleted(msg) => Status::failed_precondition(msg),

        // ... existing generic error mappings ...
    }
}
```

**Status code mappings:**
- `not_found` (5): Organization doesn't exist or soft deleted
- `already_exists` (6): Unique constraint violation
- `invalid_argument` (3): Validation failures
- `failed_precondition` (9): Operation on deleted organization

#### 4. Service Handler
**File**: `crates/ponix-grpc/src/organization_handler.rs` (new file)

```rust
use ponix_domain::organization::*;
use ponix_domain::OrganizationService;
use ponix_proto_prost::organization::v1::{
    CreateOrganizationRequest, CreateOrganizationResponse,
    GetOrganizationRequest, GetOrganizationResponse,
    UpdateOrganizationRequest, UpdateOrganizationResponse,
    DeleteOrganizationRequest, DeleteOrganizationResponse,
    ListOrganizationsRequest, ListOrganizationsResponse,
};
use ponix_proto_tonic::organization::v1::tonic::organization_service_server::OrganizationService as OrganizationServiceTrait;
use std::sync::Arc;
use tonic::{Request, Response, Status};
use tracing::{debug, info};

use crate::conversions::*;
use crate::error::domain_error_to_status;

pub struct OrganizationServiceHandler {
    domain_service: Arc<OrganizationService>,
}

impl OrganizationServiceHandler {
    pub fn new(domain_service: Arc<OrganizationService>) -> Self {
        Self { domain_service }
    }
}

#[tonic::async_trait]
impl OrganizationServiceTrait for OrganizationServiceHandler {
    async fn create_organization(
        &self,
        request: Request<CreateOrganizationRequest>,
    ) -> Result<Response<CreateOrganizationResponse>, Status> {
        let req = request.into_inner();

        debug!(name = %req.name, "Received CreateOrganization request");

        let input = to_create_organization_input(req);

        let organization = self
            .domain_service
            .create_organization(input)
            .await
            .map_err(domain_error_to_status)?;

        info!(organization_id = %organization.id, "Organization created successfully");

        let proto_org = to_proto_organization(organization);

        Ok(Response::new(CreateOrganizationResponse {
            organization: Some(proto_org),
        }))
    }

    async fn get_organization(
        &self,
        request: Request<GetOrganizationRequest>,
    ) -> Result<Response<GetOrganizationResponse>, Status> {
        let req = request.into_inner();

        debug!(organization_id = %req.organization_id, "Received GetOrganization request");

        let input = to_get_organization_input(req);

        let organization = self
            .domain_service
            .get_organization(input)
            .await
            .map_err(domain_error_to_status)?;

        let proto_org = to_proto_organization(organization);

        Ok(Response::new(GetOrganizationResponse {
            organization: Some(proto_org),
        }))
    }

    async fn update_organization(
        &self,
        request: Request<UpdateOrganizationRequest>,
    ) -> Result<Response<UpdateOrganizationResponse>, Status> {
        let req = request.into_inner();

        debug!(
            organization_id = %req.organization_id,
            name = %req.name,
            "Received UpdateOrganization request"
        );

        let input = to_update_organization_input(req);

        let organization = self
            .domain_service
            .update_organization(input)
            .await
            .map_err(domain_error_to_status)?;

        info!(organization_id = %organization.id, "Organization updated successfully");

        let proto_org = to_proto_organization(organization);

        Ok(Response::new(UpdateOrganizationResponse {
            organization: Some(proto_org),
        }))
    }

    async fn delete_organization(
        &self,
        request: Request<DeleteOrganizationRequest>,
    ) -> Result<Response<DeleteOrganizationResponse>, Status> {
        let req = request.into_inner();

        debug!(organization_id = %req.organization_id, "Received DeleteOrganization request");

        let input = to_delete_organization_input(req);

        self.domain_service
            .delete_organization(input)
            .await
            .map_err(domain_error_to_status)?;

        info!(organization_id = %req.organization_id, "Organization deleted successfully");

        Ok(Response::new(DeleteOrganizationResponse {}))
    }

    async fn list_organizations(
        &self,
        request: Request<ListOrganizationsRequest>,
    ) -> Result<Response<ListOrganizationsResponse>, Status> {
        let req = request.into_inner();

        debug!("Received ListOrganizations request");

        let input = to_list_organizations_input(req);

        let organizations = self
            .domain_service
            .list_organizations(input)
            .await
            .map_err(domain_error_to_status)?;

        info!(count = organizations.len(), "Listed organizations");

        let proto_orgs: Vec<_> = organizations
            .into_iter()
            .map(to_proto_organization)
            .collect();

        Ok(Response::new(ListOrganizationsResponse {
            organizations: proto_orgs,
        }))
    }
}
```

**Handler pattern:**
- Extract request → convert proto→domain → call service → convert domain→proto → return response
- Structured logging at each step
- Error conversion via `domain_error_to_status`

#### 5. Server Registration
**File**: `crates/ponix-grpc/src/server.rs` (modify existing)

```rust
use ponix_proto_tonic::organization::v1::tonic::organization_service_server::OrganizationServiceServer;

pub async fn run_grpc_server(
    config: GrpcServerConfig,
    device_service: Arc<DeviceService>,
    organization_service: Arc<OrganizationService>,  // Add parameter
    cancellation_token: CancellationToken,
) -> Result<(), anyhow::Error> {
    let addr: SocketAddr = format!("{}:{}", config.host, config.port).parse()?;

    info!("Starting gRPC server on {}", addr);

    let device_handler = DeviceServiceHandler::new(device_service);
    let org_handler = OrganizationServiceHandler::new(organization_service);  // Create handler

    let server = Server::builder()
        .add_service(EndDeviceServiceServer::new(device_handler))
        .add_service(OrganizationServiceServer::new(org_handler))  // Register service
        .serve_with_shutdown(addr, async move {
            cancellation_token.cancelled().await;
            info!("gRPC server shutdown signal received");
        });

    // ... rest of function ...
}
```

#### 6. Module Exports
**File**: `crates/ponix-grpc/src/lib.rs` (modify existing)

```rust
pub mod organization_handler;

pub use organization_handler::OrganizationServiceHandler;
```

### Success Criteria

#### Automated Verification:
- [ ] Type checking passes: `cargo check -p ponix-grpc`
- [ ] Linting passes: `cargo clippy -p ponix-grpc -- -D warnings`
- [ ] Unit tests pass: `cargo test -p ponix-grpc --lib`

#### Manual Verification:
- [ ] Start service: `cargo run -p ponix-all-in-one`
- [ ] Test create: `grpcurl -plaintext -d '{"name": "Test Org"}' localhost:50051 ponix.organization.v1.OrganizationService/CreateOrganization`
- [ ] Test get: `grpcurl -plaintext -d '{"organization_id": "xxx"}' localhost:50051 ponix.organization.v1.OrganizationService/GetOrganization`
- [ ] Test list: `grpcurl -plaintext -d '{}' localhost:50051 ponix.organization.v1.OrganizationService/ListOrganizations`
- [ ] Test update: `grpcurl -plaintext -d '{"organization_id": "xxx", "name": "Updated"}' localhost:50051 ponix.organization.v1.OrganizationService/UpdateOrganization`
- [ ] Test delete: `grpcurl -plaintext -d '{"organization_id": "xxx"}' localhost:50051 ponix.organization.v1.OrganizationService/DeleteOrganization`
- [ ] Verify deleted org not returned by get/list

**Implementation Note**: After completing this phase and all automated verification passes, the gRPC API is functional. Next phase will integrate organization validation with device operations.

---

## Phase 5: Device Integration - Organization Validation

### Overview
Update device queries and validation to filter out devices belonging to soft-deleted organizations. This ensures devices are hidden when their parent organization is deleted.

### Changes Required

#### 1. Device Repository Queries
**File**: `crates/ponix-postgres/src/device_repo.rs` (modify existing)

Update `get_device` query to join organizations table:

```rust
async fn get_device(&self, input: GetDeviceInput) -> DomainResult<Option<Device>> {
    let conn = self.client.get_connection().await?;

    debug!(device_id = %input.device_id, "Fetching device from database");

    let result = conn
        .query_opt(
            "SELECT d.device_id, d.organization_id, d.device_name, d.payload_conversion,
                    d.created_at, d.updated_at
             FROM devices d
             INNER JOIN organizations o ON d.organization_id = o.id
             WHERE d.device_id = $1 AND o.deleted_at IS NULL",
            &[&input.device_id],
        )
        .await?;

    // ... rest of function unchanged ...
}
```

Update `list_devices` query to join organizations table:

```rust
async fn list_devices(&self, input: ListDevicesInput) -> DomainResult<Vec<Device>> {
    let conn = self.client.get_connection().await?;

    debug!(organization_id = %input.organization_id, "Listing devices from database");

    let rows = conn
        .query(
            "SELECT d.device_id, d.organization_id, d.device_name, d.payload_conversion,
                    d.created_at, d.updated_at
             FROM devices d
             INNER JOIN organizations o ON d.organization_id = o.id
             WHERE d.organization_id = $1 AND o.deleted_at IS NULL
             ORDER BY d.created_at DESC",
            &[&input.organization_id],
        )
        .await?;

    // ... rest of function unchanged ...
}
```

**Rationale:**
- `INNER JOIN organizations o ON d.organization_id = o.id`: Links device to organization
- `o.deleted_at IS NULL`: Filters out devices from soft-deleted organizations
- Device appears deleted to API clients without actually deleting device data
- Preserves device data for potential organization restoration

#### 2. Device Creation Validation
**File**: `crates/ponix-domain/src/end_device_service.rs` (modify existing)

Add organization validation to `create_device` method. This requires adding `OrganizationRepository` as a dependency:

```rust
use crate::repository::{DeviceRepository, OrganizationRepository};
use crate::organization::GetOrganizationInput;

pub struct DeviceService {
    device_repository: Arc<dyn DeviceRepository>,
    organization_repository: Arc<dyn OrganizationRepository>,  // Add dependency
}

impl DeviceService {
    pub fn new(
        device_repository: Arc<dyn DeviceRepository>,
        organization_repository: Arc<dyn OrganizationRepository>,  // Add parameter
    ) -> Self {
        Self {
            device_repository,
            organization_repository,
        }
    }

    pub async fn create_device(&self, input: CreateDeviceInput) -> DomainResult<Device> {
        debug!(
            organization_id = %input.organization_id,
            name = %input.name,
            "Creating device"
        );

        // Validate organization_id
        if input.organization_id.is_empty() {
            return Err(DomainError::InvalidOrganizationId(
                "Organization ID cannot be empty".to_string(),
            ));
        }

        // Validate organization exists and is not deleted
        let org_result = self
            .organization_repository
            .get_organization(GetOrganizationInput {
                organization_id: input.organization_id.clone(),
            })
            .await;

        match org_result {
            Ok(None) => {
                return Err(DomainError::OrganizationNotFound(input.organization_id));
            }
            Ok(Some(org)) => {
                if org.deleted_at.is_some() {
                    return Err(DomainError::OrganizationDeleted(input.organization_id));
                }
            }
            Err(e) => return Err(e),
        }

        // Validate device name
        if input.name.is_empty() {
            return Err(DomainError::InvalidDeviceName(
                "Device name cannot be empty".to_string(),
            ));
        }

        // Generate device ID
        let device_id = xid::new().to_string();

        // ... rest of function unchanged ...
    }
}
```

**Validation logic:**
- Fetch organization before creating device
- Return `OrganizationNotFound` if organization doesn't exist
- Return `OrganizationDeleted` if organization has `deleted_at` set
- Prevents creating devices for non-existent or deleted organizations

#### 3. Update Device Service Initialization
**File**: `crates/ponix-all-in-one/src/main.rs` (modify existing)

Update initialization to pass both repositories to DeviceService:

```rust
// Create repositories
let device_repository = Arc::new(PostgresDeviceRepository::new(postgres_client.clone()));
let organization_repository = Arc::new(PostgresOrganizationRepository::new(postgres_client));

// Create services with both repositories
let device_service = Arc::new(DeviceService::new(
    device_repository.clone(),
    organization_repository.clone(),  // Pass organization repo
));

let organization_service = Arc::new(OrganizationService::new(organization_repository));
```

#### 4. Update Device Service Tests
**File**: `crates/ponix-domain/src/end_device_service.rs` (modify tests)

Update tests to mock `OrganizationRepository`:

```rust
#[tokio::test]
async fn test_create_device_success() {
    let mut mock_device_repo = MockDeviceRepository::new();
    let mut mock_org_repo = MockOrganizationRepository::new();

    // Mock organization lookup
    let org = Organization {
        id: "org-456".to_string(),
        name: "Test Org".to_string(),
        deleted_at: None,
        created_at: Some(chrono::Utc::now()),
        updated_at: Some(chrono::Utc::now()),
    };

    mock_org_repo
        .expect_get_organization()
        .withf(|input: &GetOrganizationInput| input.organization_id == "org-456")
        .times(1)
        .return_once(move |_| Ok(Some(org)));

    // Mock device creation
    let expected_device = Device { /* ... */ };

    mock_device_repo
        .expect_create_device()
        .withf(|input: &CreateDeviceInputWithId| {
            !input.device_id.is_empty() && input.organization_id == "org-456"
        })
        .times(1)
        .return_once(move |_| Ok(expected_device.clone()));

    let service = DeviceService::new(
        Arc::new(mock_device_repo),
        Arc::new(mock_org_repo),
    );

    // ... rest of test ...
}

#[tokio::test]
async fn test_create_device_deleted_organization() {
    let mock_device_repo = MockDeviceRepository::new();
    let mut mock_org_repo = MockOrganizationRepository::new();

    // Mock deleted organization
    let deleted_org = Organization {
        id: "org-deleted".to_string(),
        name: "Deleted Org".to_string(),
        deleted_at: Some(chrono::Utc::now()),
        created_at: Some(chrono::Utc::now()),
        updated_at: Some(chrono::Utc::now()),
    };

    mock_org_repo
        .expect_get_organization()
        .times(1)
        .return_once(move |_| Ok(Some(deleted_org)));

    let service = DeviceService::new(
        Arc::new(mock_device_repo),
        Arc::new(mock_org_repo),
    );

    let input = CreateDeviceInput {
        organization_id: "org-deleted".to_string(),
        name: "Test Device".to_string(),
        payload_conversion: "test".to_string(),
    };

    let result = service.create_device(input).await;
    assert!(matches!(result, Err(DomainError::OrganizationDeleted(_))));
}
```

### Success Criteria

#### Automated Verification:
- [ ] Domain tests pass: `cargo test -p ponix-domain`
- [ ] Integration tests pass: `cargo test -p ponix-postgres --features integration-tests -- --test-threads=1`
- [ ] Type checking passes: `cargo check --workspace`
- [ ] All device service unit tests updated and passing

#### Manual Verification:
- [ ] Create organization via gRPC
- [ ] Create device with organization_id
- [ ] Soft delete organization
- [ ] Verify device no longer returned by GetEndDevice
- [ ] Verify device no longer in ListEndDevices
- [ ] Verify cannot create new device with deleted organization_id

**Implementation Note**: After completing this phase, devices are properly integrated with organization soft delete behavior.

---

## Phase 6: Envelope Service Integration

### Overview
Update `RawEnvelopeService` to reject raw messages from devices belonging to soft-deleted organizations. This prevents processing data from inactive organizations.

### Changes Required

#### 1. Update Device Repository Query in RawEnvelopeService
**File**: `crates/ponix-postgres/src/device_repo.rs`

No code changes needed - the query updates from Phase 5 already handle this. The `get_device` method now joins the organizations table and filters `o.deleted_at IS NULL`.

When `RawEnvelopeService.process_raw_envelope()` calls `device_repository.get_device()`, it will return:
- `None` if device doesn't exist
- `None` if device's organization is soft-deleted (filtered by JOIN + WHERE clause)

#### 2. Add Unit Test for Deleted Organization Scenario
**File**: `crates/ponix-domain/src/raw_envelope_service.rs` (modify existing)

Add test case for envelope from device with deleted organization:

```rust
#[tokio::test]
async fn test_process_raw_envelope_deleted_organization() {
    // Arrange
    let mut mock_device_repo = MockDeviceRepository::new();
    let mock_converter = MockPayloadConverter::new();
    let mock_producer = MockProcessedEnvelopeProducer::new();

    // Repository returns None because organization is deleted (filtered at DB level)
    mock_device_repo
        .expect_get_device()
        .withf(|input: &GetDeviceInput| input.device_id == "device-with-deleted-org")
        .times(1)
        .return_once(|_| Ok(None));

    let service = RawEnvelopeService::new(
        Arc::new(mock_device_repo),
        Arc::new(mock_converter),
        Arc::new(mock_producer),
    );

    let raw_envelope = RawEnvelope {
        organization_id: "deleted-org".to_string(),
        end_device_id: "device-with-deleted-org".to_string(),
        occurred_at: chrono::Utc::now(),
        payload: vec![0x01, 0x67, 0x01, 0x10],
    };

    // Act
    let result = service.process_raw_envelope(raw_envelope).await;

    // Assert
    assert!(matches!(result, Err(DomainError::DeviceNotFound(_))));
}
```

**Test rationale:**
- Repository query filters out devices from deleted organizations at DB level
- Service receives `None` from repository
- Service returns `DeviceNotFound` error (existing behavior)
- No special handling needed in service layer - infrastructure handles it

#### 3. Integration Test
**File**: `crates/ponix-postgres/tests/repository_integration.rs` (modify existing)

Add integration test verifying device queries filter deleted organizations:

```rust
#[tokio::test]
#[cfg_attr(not(feature = "integration-tests"), ignore)]
async fn test_device_query_filters_deleted_organization() {
    let (_container, device_repo, org_repo) = setup_test_db().await;

    // Create organization
    let org_input = CreateOrganizationInputWithId {
        id: "test-org-999".to_string(),
        name: "Test Org".to_string(),
    };
    org_repo.create_organization(org_input).await.unwrap();

    // Create device
    let device_input = CreateDeviceInputWithId {
        device_id: "test-device-999".to_string(),
        organization_id: "test-org-999".to_string(),
        name: "Test Device".to_string(),
        payload_conversion: "test".to_string(),
    };
    device_repo.create_device(device_input).await.unwrap();

    // Verify device is retrievable
    let device = device_repo
        .get_device(GetDeviceInput {
            device_id: "test-device-999".to_string(),
        })
        .await
        .unwrap();
    assert!(device.is_some());

    // Soft delete organization
    org_repo
        .delete_organization(DeleteOrganizationInput {
            organization_id: "test-org-999".to_string(),
        })
        .await
        .unwrap();

    // Verify device is no longer retrievable (filtered by deleted organization)
    let device_after_org_delete = device_repo
        .get_device(GetDeviceInput {
            device_id: "test-device-999".to_string(),
        })
        .await
        .unwrap();
    assert!(device_after_org_delete.is_none());
}
```

**Test setup note**: The `setup_test_db` function will need to return both device and organization repositories.

### Success Criteria

#### Automated Verification:
- [ ] Unit tests pass: `cargo test -p ponix-domain`
- [ ] Integration tests pass: `cargo test -p ponix-postgres --features integration-tests -- --test-threads=1`
- [ ] Type checking passes: `cargo check --workspace`

#### Manual Verification:
- [ ] Create organization and device
- [ ] Publish raw envelope to NATS for that device (verify processing succeeds)
- [ ] Soft delete organization
- [ ] Publish raw envelope to NATS for same device (verify processing fails with DeviceNotFound)
- [ ] Check logs for appropriate error message

**Implementation Note**: After completing this phase, the envelope processing pipeline properly rejects messages from devices with deleted organizations.

---

## Phase 7: Testing & Validation

### Overview
Ensure comprehensive test coverage across all layers and validate the complete feature end-to-end.

### Changes Required

#### 1. Update Test Setup Helper
**File**: `crates/ponix-postgres/tests/common.rs` (new file or modify existing)

Create shared test setup that returns both repositories:

```rust
use ponix_postgres::{MigrationRunner, PostgresClient, PostgresDeviceRepository, PostgresOrganizationRepository};
use testcontainers::clients::Cli;
use testcontainers_modules::postgres::Postgres;

pub async fn setup_test_db() -> (
    testcontainers::Container<'static, Postgres>,
    PostgresDeviceRepository,
    PostgresOrganizationRepository,
) {
    let docker = Cli::default();
    let postgres = docker.run(Postgres::default());

    let host = "localhost";
    let port = postgres.get_host_port_ipv4(5432);

    // Run migrations
    let migrations_dir = format!("{}/migrations", env!("CARGO_MANIFEST_DIR"));
    let dsn = format!("postgres://postgres:postgres@{}:{}/postgres?sslmode=disable", host, port);
    let goose_path = which::which("goose").expect("goose not found");

    let migration_runner = MigrationRunner::new(
        goose_path.to_string_lossy().to_string(),
        migrations_dir,
        "postgres".to_string(),
        dsn,
    );

    migration_runner.run_migrations().await.expect("Migrations failed");

    // Create client
    let client = PostgresClient::new(host, port, "postgres", "postgres", "postgres", 5).unwrap();

    let device_repo = PostgresDeviceRepository::new(client.clone());
    let org_repo = PostgresOrganizationRepository::new(client);

    (postgres, device_repo, org_repo)
}
```

#### 2. Comprehensive End-to-End Test
**File**: `crates/ponix-postgres/tests/organization_device_integration.rs` (new file)

```rust
use ponix_domain::organization::*;
use ponix_domain::types::{CreateDeviceInputWithId, GetDeviceInput};
use ponix_domain::repository::{DeviceRepository, OrganizationRepository};

mod common;

#[tokio::test]
#[cfg_attr(not(feature = "integration-tests"), ignore)]
async fn test_organization_soft_delete_hides_devices() {
    let (_container, device_repo, org_repo) = common::setup_test_db().await;

    // Step 1: Create organization
    let org = org_repo
        .create_organization(CreateOrganizationInputWithId {
            id: "e2e-org".to_string(),
            name: "E2E Test Org".to_string(),
        })
        .await
        .unwrap();

    assert_eq!(org.name, "E2E Test Org");
    assert!(org.deleted_at.is_none());

    // Step 2: Create multiple devices for organization
    for i in 1..=3 {
        device_repo
            .create_device(CreateDeviceInputWithId {
                device_id: format!("e2e-device-{}", i),
                organization_id: "e2e-org".to_string(),
                name: format!("Device {}", i),
                payload_conversion: "test".to_string(),
            })
            .await
            .unwrap();
    }

    // Step 3: Verify devices are retrievable
    for i in 1..=3 {
        let device = device_repo
            .get_device(GetDeviceInput {
                device_id: format!("e2e-device-{}", i),
            })
            .await
            .unwrap();
        assert!(device.is_some());
    }

    // Step 4: Soft delete organization
    org_repo
        .delete_organization(DeleteOrganizationInput {
            organization_id: "e2e-org".to_string(),
        })
        .await
        .unwrap();

    // Step 5: Verify organization is not returned by get
    let org_after_delete = org_repo
        .get_organization(GetOrganizationInput {
            organization_id: "e2e-org".to_string(),
        })
        .await
        .unwrap();
    assert!(org_after_delete.is_none());

    // Step 6: Verify devices are no longer retrievable
    for i in 1..=3 {
        let device = device_repo
            .get_device(GetDeviceInput {
                device_id: format!("e2e-device-{}", i),
            })
            .await
            .unwrap();
        assert!(device.is_none(), "Device {} should be hidden after org delete", i);
    }

    // Step 7: Verify organization still exists in database with deleted_at set
    // (This would require a raw SQL query or a special repository method)
    // For now, we've verified the soft delete behavior through the API
}

#[tokio::test]
#[cfg_attr(not(feature = "integration-tests"), ignore)]
async fn test_organization_crud_operations() {
    let (_container, _device_repo, org_repo) = common::setup_test_db().await;

    // Create
    let org = org_repo
        .create_organization(CreateOrganizationInputWithId {
            id: "crud-test".to_string(),
            name: "Original Name".to_string(),
        })
        .await
        .unwrap();
    assert_eq!(org.name, "Original Name");

    // Get
    let fetched = org_repo
        .get_organization(GetOrganizationInput {
            organization_id: "crud-test".to_string(),
        })
        .await
        .unwrap();
    assert!(fetched.is_some());
    assert_eq!(fetched.unwrap().name, "Original Name");

    // Update
    let updated = org_repo
        .update_organization(UpdateOrganizationInput {
            organization_id: "crud-test".to_string(),
            name: "Updated Name".to_string(),
        })
        .await
        .unwrap();
    assert_eq!(updated.name, "Updated Name");

    // List
    let orgs = org_repo
        .list_organizations(ListOrganizationsInput {})
        .await
        .unwrap();
    assert!(orgs.iter().any(|o| o.id == "crud-test"));

    // Delete
    org_repo
        .delete_organization(DeleteOrganizationInput {
            organization_id: "crud-test".to_string(),
        })
        .await
        .unwrap();

    // Verify deleted
    let after_delete = org_repo
        .get_organization(GetOrganizationInput {
            organization_id: "crud-test".to_string(),
        })
        .await
        .unwrap();
    assert!(after_delete.is_none());
}
```

#### 3. Test Coverage Summary

Ensure tests exist for:

**Domain Layer** (`ponix-domain`):
- [x] OrganizationService: create with valid/invalid inputs
- [x] OrganizationService: get existing/non-existent
- [x] OrganizationService: update organization
- [x] OrganizationService: delete organization
- [x] OrganizationService: list organizations
- [x] DeviceService: create device with deleted organization (error)
- [x] RawEnvelopeService: process envelope from device with deleted org (error)

**Infrastructure Layer** (`ponix-postgres`):
- [x] OrganizationRepository: create with unique ID
- [x] OrganizationRepository: create duplicate (unique constraint error)
- [x] OrganizationRepository: get organization
- [x] OrganizationRepository: update organization
- [x] OrganizationRepository: soft delete (sets deleted_at)
- [x] OrganizationRepository: list excludes deleted
- [x] DeviceRepository: get device filters deleted organization
- [x] DeviceRepository: list devices filters deleted organization

**API Layer** (`ponix-grpc`):
- [x] Type conversions: proto ↔ domain
- [x] Error mapping: DomainError → gRPC Status

**End-to-End**:
- [x] Organization CRUD via gRPC
- [x] Device creation with organization validation
- [x] Organization soft delete hides devices
- [x] Envelope processing rejects deleted organization devices

### Success Criteria

#### Automated Verification:
- [ ] All workspace tests pass: `cargo test --workspace --lib`
- [ ] All integration tests pass: `cargo test --workspace --features integration-tests -- --test-threads=1`
- [ ] Type checking passes: `cargo check --workspace`
- [ ] Linting passes: `cargo clippy --workspace -- -D warnings`
- [ ] Code formatting: `cargo fmt --all -- --check`
- [ ] Documentation builds: `cargo doc --workspace --no-deps`

#### Manual Verification:
- [ ] Start full service: `mise run test:integration` or `docker-compose -f docker/docker-compose.deps.yaml up -d && cargo run -p ponix-all-in-one`
- [ ] Test full organization lifecycle via grpcurl:
  - Create organization
  - Get organization
  - Update organization
  - List organizations
  - Delete organization
  - Verify deleted org not in get/list
- [ ] Test device integration:
  - Create organization
  - Create device with organization_id
  - Verify device retrievable
  - Delete organization
  - Verify device no longer retrievable
  - Verify cannot create new device with deleted org_id
- [ ] Test envelope processing:
  - Create organization and device
  - Send raw envelope (verify processing succeeds)
  - Delete organization
  - Send raw envelope (verify processing fails)

**Implementation Note**: After completing this phase and all verification passes, the organization feature is complete and production-ready.

---

## Testing Strategy

### Unit Tests
- **Domain Layer**: Service logic validation, input validation, error handling
- **Infrastructure Layer**: Type conversions, error mapping
- **All tests use Mockall** for repository mocking

### Integration Tests
- **PostgreSQL Repository**: Database operations with testcontainers
- **End-to-End**: Organization + device interactions across multiple repositories
- **Run with**: `cargo test --workspace --features integration-tests -- --test-threads=1`

### Manual Testing
- **gRPC API**: Test all endpoints via grpcurl
- **Database Inspection**: Verify soft delete behavior in PostgreSQL
- **Envelope Processing**: Test raw message rejection for deleted organizations

## Performance Considerations

- **Indexes**: Added `idx_organizations_deleted_at` for efficient soft delete filtering
- **JOIN Performance**: Device queries now join organizations table - index on FK improves performance
- **Connection Pooling**: All repositories use connection pool from `PostgresClient`
- **Batch Operations**: List operations return all results (no pagination in initial implementation)

## Migration Notes

- **No Data Migration**: No existing data to migrate
- **Schema Evolution**: Migrations are reversible via goose Down blocks
- **Foreign Key**: Constraint added after organizations table exists
- **Zero Downtime**: Migrations can be applied before code deployment

## References

- Original issue: [ponix-dev/ponix-rs#41](https://github.com/ponix-dev/ponix-rs/issues/41)
- Device implementation patterns:
  - Domain layer: [crates/ponix-domain/src/end_device_service.rs](crates/ponix-domain/src/end_device_service.rs)
  - Repository: [crates/ponix-postgres/src/device_repo.rs](crates/ponix-postgres/src/device_repo.rs)
  - gRPC handler: [crates/ponix-grpc/src/device_handler.rs](crates/ponix-grpc/src/device_handler.rs)
- Envelope service: [crates/ponix-domain/src/raw_envelope_service.rs](crates/ponix-domain/src/raw_envelope_service.rs)
- BSR configuration: [crates/ponix-grpc/Cargo.toml](crates/ponix-grpc/Cargo.toml)
